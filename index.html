<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Chessy: Pro</title>
    
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/44/44205.png">
    
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-bg: #2a2a2a;
            --text-main: #f0f0f0;
            --text-muted: #888;
            --accent: #61afef;
            --accent-glow: rgba(97, 175, 239, 0.3);
            --danger: #e03131;
            --board-border: #3d2b1f;
            --square-light: #ebecd0;
            --square-dark: #779556;
            --highlight-move: rgba(255, 255, 50, 0.5);
            --highlight-last: rgba(155, 255, 50, 0.5);
            --highlight-check: #ff4444;
            --book-color: #3b82f6;
            --hint-color: #26c281;
        }

        /* Theme Classes */
        body.theme-wood { --board-border: #4d3324; --square-light: #f0d9b5; --square-dark: #b58863; }
        body.theme-ocean { --board-border: #2c3e50; --square-light: #dee3e6; --square-dark: #8ca2ad; }
        body.theme-midnight { --board-border: #000; --square-light: #706f78; --square-dark: #353436; }

        /* Piece Styles */
        .piece { 
            z-index: 2; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; 
            transition: transform 0.3s; font-weight: normal; line-height: 1; padding-bottom: 5px; 
        }
        .piece.white { color: #fff; text-shadow: 0 0 2px #000, 1px 1px 2px #000; }
        .piece.black { color: #111; text-shadow: 0 0 1px #fff; }
        .piece.black.flipped { transform: rotate(180deg); }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body { 
            font-family: 'Segoe UI', system-ui, sans-serif; background-color: var(--bg-color); color: var(--text-main); 
            margin: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100dvh; overflow: hidden; 
        }

        .game-area { display: none; flex-direction: column; align-items: center; width: 100%; height: 100%; max-width: 600px; padding: 5px; }
        .game-area.active { display: flex; }

        .game-main-row { display: flex; gap: 10px; width: 100%; max-width: 80vh; aspect-ratio: 1; margin-bottom: 5px; align-items: stretch; }
        
        .eval-bar-container {
            width: 20px; min-width: 20px; 
            background: #333; border-radius: 4px; overflow: hidden; display: flex; flex-direction: column-reverse;
            border: 2px solid var(--panel-bg); position: relative; visibility: hidden; opacity: 0; transition: opacity 0.5s ease;
        }
        .eval-bar-container.visible { visibility: visible; opacity: 1; }
        .eval-fill { width: 100%; height: 50%; background: #fff; transition: height 0.3s ease-out; }
        .eval-score { position: absolute; width: 100%; text-align: center; font-size: 9px; font-weight: bold; color: #555; mix-blend-mode: difference; bottom: 5px; z-index: 2; }

        .board-container { flex: 1; border: 6px solid var(--board-border); border-radius: 4px; position: relative; }
        .board-grid { display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 100%; height: 100%; background: var(--board-border); }
        
        .square { position: relative; display: flex; justify-content: center; align-items: center; font-size: clamp(32px, 11vw, 70px); cursor: pointer; }
        .square.light { background-color: var(--square-light); }
        .square.dark { background-color: var(--square-dark); }
        .square.selected { background-color: var(--highlight-move) !important; }
        .square.last-move { background-color: var(--highlight-last); }
        .square.in-check { background-color: var(--highlight-check) !important; }
        .square.valid-move::after { content: ''; position: absolute; width: 22%; height: 22%; background: rgba(0,0,0,0.25); border-radius: 50%; }
        .square.valid-capture::after { content: ''; position: absolute; width: 85%; height: 85%; border: 5px solid rgba(0,0,0,0.25); border-radius: 50%; }

        .board-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .annotation {
            position: absolute; top: -8px; right: -8px; width: 26px; height: 26px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center; font-size: 14px; font-weight: 900;
            color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.5); z-index: 5;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); border: 2px solid white;
        }
        @keyframes popIn { from { transform: scale(0); } to { transform: scale(1); } }
        .anno-brilliant { background: #26c281; } .anno-good { background: #81b214; }
        .anno-mistake { background: #f59f00; } .anno-blunder { background: #e03131; }
        .anno-book { background: var(--book-color); font-size: 16px; }

        .clock-container { display: flex; justify-content: space-between; width: 100%; max-width: 80vh; margin-bottom: 5px; }
        .player-info { background: var(--panel-bg); padding: 5px 12px; border-radius: 6px; display: flex; align-items: center; gap: 10px; min-width: 100px; border: 2px solid transparent; }
        .player-info.active { border-color: var(--accent); background: #3a3a3a; }
        .clock-time { font-family: monospace; font-size: 1.4rem; font-weight: bold; }

        .history-panel { background: var(--panel-bg); width: 100%; max-width: 80vh; flex: 1; min-height: 40px; border-radius: 6px; overflow-y: auto; display: flex; flex-direction: column; padding: 5px; font-family: monospace; margin-bottom: 10px; }
        .history-row { display: grid; grid-template-columns: 40px 1fr 1fr; padding: 4px; border-bottom: 1px solid #333; font-size: 0.9rem; cursor: pointer; }
        .history-row:hover { background: rgba(255,255,255,0.05); }
        .history-row.active-row { background: rgba(97, 175, 239, 0.2); border-left: 3px solid var(--accent); }
        .history-num { color: var(--text-muted); } .history-move { color: #ddd; }
        .hist-anno { display: inline-block; margin-left:5px; font-weight:bold; }
        .hist-anno.good { color: #81b214; } .hist-anno.bad { color: #f59f00; } .hist-anno.blunder { color: #e03131; }
        .hist-anno.book { color: var(--book-color); font-size: 1.1em; }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(15,15,15,0.96); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 15px; overflow-y: auto; padding: 20px; }
        .overlay.hidden { display: none; }
        h1 { margin: 0 0 10px 0; color: var(--accent); font-size: 3rem; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 20px rgba(97, 175, 239, 0.2); }
        
        .menu-container { width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 15px; position: relative; }
        .menu-section { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 12px; text-align: center; border: 1px solid rgba(255,255,255,0.05); }
        .menu-section h3 { margin: 0 0 10px 0; font-size: 0.9rem; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        
        .btn-group { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
        
        button { background: #333; color: #bbb; border: 1px solid #444; padding: 10px 16px; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-size: 0.95rem; }
        button:hover { background: #3d3d3d; color: #fff; }
        button.selected { background: var(--accent); color: #111; font-weight: bold; border-color: var(--accent); box-shadow: 0 0 15px var(--accent-glow); }
        
        button.primary { background: linear-gradient(135deg, var(--accent), #4fa3e0); color: #111; font-weight: 800; padding: 18px 40px; font-size: 1.4rem; border: none; margin-top: 10px; width: 100%; border-radius: 8px; text-transform: uppercase; letter-spacing: 1px; box-shadow: 0 4px 20px rgba(97, 175, 239, 0.4); }
        button.primary:hover { transform: translateY(-2px); box-shadow: 0 6px 25px rgba(97, 175, 239, 0.5); }
        
        .quit-btn { background: var(--danger); color: white; border-color: var(--danger); } .quit-btn:hover { background: #ff4444; }
        .undo-btn { background: #d69e2e; color: white; border-color: #d69e2e; } .undo-btn:hover { background: #f0b33c; }
        .export-btn { background: #6c757d; color: white; border-color: #6c757d; } .export-btn:hover { background: #5a6268; }

        .suggest-btn { background: var(--hint-color); color: #fff; width: 100%; margin-bottom: 5px; border-color: var(--hint-color); display: none; }
        .suggest-btn.visible { display: block; }
        .suggest-btn:hover { background: #1a9e69; }

        #lang-toggle { position: absolute; top: -50px; right: 0; background: transparent; border: 1px solid #444; font-size: 1.5rem; padding: 5px 10px; border-radius: 8px; }

        #nav-controls { display: none; gap: 10px; width: 100%; justify-content: center; margin-top: 5px; flex-wrap: wrap; }
        #nav-controls.visible { display: flex; }
        .nav-btn { font-size: 1.2rem; padding: 5px 20px; font-weight: bold; background: var(--panel-bg); color: white; }
        .nav-btn:hover { background: #444; }

        #promotion-modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 10px; border-radius: 8px; display: none; gap: 8px; z-index: 50; }
        #promotion-modal.active { display: flex; }
        .promo-btn { font-size: 35px; background: #eee; width: 50px; height: 50px; display: flex; justify-content: center; align-items: center; cursor: pointer; color: black; border-radius: 4px; }
        
        .control-bar { display: flex; gap: 10px; width: 100%; max-width: 80vh; padding-bottom: env(safe-area-inset-bottom); margin-bottom: 5px; flex-shrink: 0; }
        .control-bar button { flex: 1; font-weight: 600; padding: 15px 5px; }

        .loader { border: 5px solid #333; border-top: 5px solid var(--accent); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #loading-overlay { z-index: 150; background: rgba(0,0,0,0.85); justify-content: center; }
        .hidden-opt { display: none; }
        
        /* Export Modal Specifics */
        .export-area { width: 100%; height: 100px; background: #222; color: #ddd; border: 1px solid #444; border-radius: 6px; padding: 10px; font-family: monospace; font-size: 0.85rem; resize: none; margin-bottom: 10px; }
        .copy-row { display: flex; gap: 10px; margin-bottom: 15px; }
        .copy-row button { flex: 1; padding: 12px; font-size: 0.9rem; }
    </style>
</head>
<body class="theme-wood style-classic">

    <div id="main-menu" class="overlay">
        <h1>Chessy</h1>
        <div class="menu-container">
            <button id="lang-toggle" onclick="app.toggleLanguage()">üáπüá∑</button>
            <div class="menu-section">
                <h3 data-key="gameSetup">Game Setup</h3>
                <div class="btn-group" style="margin-bottom: 15px;">
                    <button class="mode-btn selected" data-mode="pvp" data-key="pvp">Human vs Human</button>
                    <button class="mode-btn" data-mode="pvc" data-key="pvc">Play vs Bot</button>
                </div>
                <div id="diff-sec" class="hidden-opt" style="margin-top:10px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
                    <div style="color:#888; margin-bottom:5px; font-size:0.9rem;"><span data-key="botLevel">Bot Level</span>: <span id="lvl-txt" style="color:#fff; font-weight:bold;">1</span></div>
                    <input type="range" id="bot-level" min="1" max="8" value="1" style="width:100%; cursor: pointer;">
                </div>
            </div>
            <div class="menu-section">
                <h3 data-key="timeControl">Time Control</h3>
                <div class="btn-group">
                    <button class="time-btn" data-time="1">1m</button>
                    <button class="time-btn" data-time="3">3m</button>
                    <button class="time-btn" data-time="5">5m</button>
                    <button class="time-btn selected" data-time="10">10m</button>
                    <button class="time-btn" data-time="30">30m</button>
                    <button class="time-btn" data-time="0">‚àû</button>
                </div>
            </div>
            <div class="menu-section">
                <h3 data-key="boardStyle">Board Style</h3>
                <div class="btn-group" style="margin-bottom: 10px;">
                    <button class="theme-btn selected" data-theme="" data-key="wood">Wood</button>
                    <button class="theme-btn" data-theme="theme-ocean" data-key="sea">Sea</button>
                    <button class="theme-btn" data-theme="theme-midnight" data-key="dark">Dark</button>
                </div>
                <div style="margin-top:10px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
                    <button id="flip-btn" onclick="app.toggleFlip()"><span data-key="flip">2 Player Flip</span>: OFF</button>
                </div>
            </div>
            <button class="primary" onclick="app.startGame()" data-key="start">START GAME</button>
        </div>
    </div>

    <div id="resign-modal" class="overlay hidden" style="background: rgba(0,0,0,0.8);">
        <div class="menu-section" style="max-width:300px; padding: 20px;">
            <h2 style="margin:0 0 15px 0; color:white; font-size:1.5rem;" data-key="resignTitle">Resign Game?</h2>
            <p style="color:#aaa; margin-bottom: 20px;" data-key="resignConfirm">Are you sure you want to give up?</p>
            <div class="btn-group">
                <button class="quit-btn" onclick="app.doResign()" data-key="yesResign">Yes, Resign</button>
                <button onclick="document.getElementById('resign-modal').classList.add('hidden')" data-key="cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div id="export-modal" class="overlay hidden" style="background: rgba(0,0,0,0.9);">
        <div class="menu-section" style="width:90%; max-width:500px; padding: 20px;">
            <h2 style="margin:0 0 15px 0; color:var(--accent); font-size:1.5rem;">Export Game</h2>
            
            <h3 style="text-align:left; color:#888; margin-bottom:5px;">PGN</h3>
            <textarea id="pgn-area" class="export-area" readonly></textarea>
            <button onclick="app.copyPGN()" style="width:100%; margin-bottom:20px;">Copy PGN</button>

            <h3 style="text-align:left; color:#888; margin-bottom:5px;">FEN</h3>
            <div class="copy-row">
                <input type="text" id="fen-area" class="export-area" style="height:40px; margin-bottom:0;" readonly>
                <button onclick="app.copyFEN()" style="width:auto; white-space:nowrap;">Copy FEN</button>
            </div>

            <button onclick="document.getElementById('export-modal').classList.add('hidden')" style="background:#444; margin-top:10px;">Close</button>
        </div>
    </div>

    <div id="game-over-modal" class="overlay hidden">
        <h2 id="end-title" data-key="gameOver">Game Over</h2>
        <p id="end-reason" style="color:#ccc"></p>
        <div style="display:flex; gap:10px; width:100%; max-width:300px; flex-direction: column;">
             <button class="primary" onclick="app.startAnalysis()" style="background:#26c281; color:white; border:none; width:100%;" data-key="analyze">Analyze Game</button>
             <div style="display:flex; gap:10px; width:100%;">
                <button onclick="app.showExportMenu()" style="flex:1;">Export PGN/FEN</button>
                <button onclick="app.showMainMenu()" style="flex:1;" data-key="mainMenu">Menu</button>
             </div>
        </div>
    </div>

    <div id="loading-overlay" class="overlay hidden">
        <div class="loader"></div>
        <h2 style="font-size:1.4rem; color: white;" data-key="analyzing">Deep Analyzing...</h2>
        <p style="color:#aaa" data-key="calc">Checking Opening Book & Calculating...</p>
    </div>

    <div id="game-area" class="game-area">
        <div class="clock-container">
            <div id="top-player" class="player-info"><span id="top-label">Opponent</span> <span id="clock-top" class="clock-time">10:00</span></div>
        </div>

        <div class="game-main-row">
            <div id="eval-bar" class="eval-bar-container">
                <div class="eval-fill" id="eval-fill"></div>
                <div class="eval-score" id="eval-text">0.0</div>
            </div>

            <div class="board-container">
                <div id="board" class="board-grid"></div>
                <svg id="board-overlay" class="board-overlay" viewBox="0 0 100 100" preserveAspectRatio="none">
                    <defs>
                        <marker id="arrowhead" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
                            <path d="M0,0 L0,6 L6,3 z" fill="#26c281" />
                        </marker>
                    </defs>
                    <g id="arrow-layer"></g>
                </svg>
                
                <div id="promotion-modal">
                    <div class="promo-btn" data-role="q">‚ôõ</div>
                    <div class="promo-btn" data-role="r">‚ôú</div>
                    <div class="promo-btn" data-role="b">‚ôù</div>
                    <div class="promo-btn" data-role="n">‚ôû</div>
                </div>
            </div>
        </div>

        <div class="clock-container">
            <div id="bottom-player" class="player-info"><span data-key="you">You</span> <span id="clock-bottom" class="clock-time">10:00</span></div>
        </div>

        <div id="nav-controls">
            <div style="width:100%; display:flex; gap:10px; justify-content:center;">
                <button class="nav-btn" onclick="app.navStart()">|&lt;</button>
                <button class="nav-btn" onclick="app.navPrev()">&lt;</button>
                <button class="nav-btn" onclick="app.navNext()">&gt;</button>
                <button class="nav-btn" onclick="app.navEnd()">&gt;|</button>
            </div>
            <button id="suggest-btn" class="suggest-btn" onclick="app.suggestMove()">üí° Suggest Move</button>
        </div>

        <div id="history-panel" class="history-panel"></div>

        <div class="control-bar">
            <button class="quit-btn" onclick="app.showMainMenu()" data-key="quit">Quit</button>
            <button class="export-btn" onclick="app.showExportMenu()">Export</button>
            <button class="undo-btn" onclick="app.undoMove()" data-key="undo">Undo</button>
            <button onclick="app.promptResign()" data-key="resign">Resign</button>
        </div>
    </div>

    <script>
        document.addEventListener("contextmenu", function(event){
        event.preventDefault();
        });
        
        document.onkeydown = function(e) {
            if (
                (e.ctrlKey && e.keyCode === 85) || // Ctrl + U
                (e.ctrlKey && e.shiftKey && e.keyCode === 73) || // Ctrl + Shift + I
                (e.ctrlKey && e.shiftKey && e.keyCode === 74) || // Ctrl + Shift + J
                (e.keyCode === 123) // F12
            ) {
                e.preventDefault(); // Crucial: This stops the browser's default action
                return false;
            }
        }
    </script>
    
    <script>
        const I18N = {
            en: {
                gameSetup: "Game Setup", pvp: "Human vs Human", pvc: "Play vs Bot", botLevel: "Bot Level",
                timeControl: "Time Control", boardStyle: "Board Style", wood: "Wood", sea: "Sea", dark: "Dark",
                flip: "2 Player Flip", start: "START GAME", opponent: "Opponent", you: "You",
                quit: "Quit", undo: "Undo", resign: "Resign", gameOver: "Game Over", analyze: "Analyze Game",
                mainMenu: "Main Menu", analyzing: "Deep Analyzing...", calc: "Checking Opening Book & Calculation",
                resignTitle: "Resign Game?", resignConfirm: "Are you sure you want to give up?",
                yesResign: "Yes, Resign", cancel: "Cancel",
                whiteWon: "White Won", blackWon: "Black Won", draw: "Draw", resigned: "Resigned",
                checkmate: "Checkmate", stalemate: "Stalemate", time: "Time"
            },
            tr: {
                gameSetup: "Oyun Ayarlarƒ±", pvp: "ƒ∞nsan vs ƒ∞nsan", pvc: "Bot'a Kar≈üƒ±", botLevel: "Bot Seviyesi",
                timeControl: "S√ºre Kontrol√º", boardStyle: "Tahta Stili", wood: "Ah≈üap", sea: "Deniz", dark: "Koyu",
                flip: "2. Oyuncu D√∂nd√ºr", start: "OYUNU BA≈ûLAT", opponent: "Rakip", you: "Sen",
                quit: "√áƒ±k", undo: "Geri Al", resign: "Teslim Ol", gameOver: "Oyun Bitti", analyze: "Oyunu Analiz Et",
                mainMenu: "Ana Men√º", analyzing: "Derin Analiz...", calc: "A√ßƒ±lƒ±≈ü Kitabƒ± & Hesaplama",
                resignTitle: "Teslim Ol?", resignConfirm: "Pes etmek istediƒüine emin misin?",
                yesResign: "Evet, Teslim Ol", cancel: "ƒ∞ptal",
                whiteWon: "Beyaz Kazandƒ±", blackWon: "Siyah Kazandƒ±", draw: "Berabere", resigned: "Teslim Oldu",
                checkmate: "≈ûah Mat", stalemate: "Pat", time: "S√ºre Bitti"
            }
        };

        const PIECES = { w: { k:'‚ôö', q:'‚ôõ', r:'‚ôú', b:'‚ôù', n:'‚ôû', p:'‚ôü' }, b: { k:'‚ôö', q:'‚ôõ', r:'‚ôú', b:'‚ôù', n:'‚ôû', p:'‚ôü' } };
        // For standard notation (SAN)
        const SAN_PIECES = { k:'K', q:'Q', r:'R', b:'B', n:'N', p:'' };

        const COLS = ['a','b','c','d','e','f','g','h'];
        const MG_PST = {
            p: [ 0,  0,  0,  0,  0,  0,  0,  0, 50, 50, 50, 50, 50, 50, 50, 50, 10, 10, 20, 30, 30, 20, 10, 10, 5,  5, 10, 25, 25, 10,  5,  5, 0,  0,  0, 20, 20,  0,  0,  0, 5, -5,-10,  0,  0,-10, -5,  5, 5, 10, 10,-20,-20, 10, 10,  5, 0,  0,  0,  0,  0,  0,  0,  0],
            n: [-50,-40,-30,-30,-30,-30,-40,-50,-40,-20,  0,  0,  0,  0,-20,-40,-30,  0, 10, 15, 15, 10,  0,-30,-30,  5, 15, 20, 20, 15,  5,-30,-30,  0, 15, 20, 20, 15,  0,-30,-30,  5, 10, 15, 15, 10,  5,-30,-40,-20,  0,  5,  5,  0,-20,-40,-50,-40,-30,-30,-30,-40,-50],
            b: [-20,-10,-10,-10,-10,-10,-10,-20,-10,  0,  0,  0,  0,  0,  0,-10,-10,  0,  5, 10, 10,  5,  0,-10,-10,  5,  5, 10, 10,  5,  5,-10,-10,  0, 10, 10, 10, 10,  0,-10,-10, 10, 10, 10, 10, 10, 10,-10,-10,  5,  0,  0,  0,  0,  5,-10,-20,-10,-10,-10,-10,-10,-10,-20],
            r: [  0,  0,  0,  0,  0,  0,  0,  0,  5, 10, 10, 10, 10, 10, 10,  5, -5,  0,  0,  0,  0,  0,  0, -5, -5,  0,  0,  0,  0,  0,  0, -5, -5,  0,  0,  0,  0,  0,  0, -5, -5,  0,  0,  0,  0,  0,  0, -5, -5,  0,  0,  0,  0,  0,  0, -5,  0,  0,  0,  5,  5,  0,  0,  0],
            q: [-20,-10,-10, -5, -5,-10,-10,-20,-10,  0,  0,  0,  0,  0,  0,-10,-10,  0,  5,  5,  5,  5,  0,-10, -5,  0,  5,  5,  5,  5,  0, -5,  0,  0,  5,  5,  5,  5,  0, -5,-10,  5,  5,  5,  5,  5,  0,-10,-10,  0,  5,  0,  0,  0,  0,-10,-20,-10,-10, -5, -5,-10,-10,-20],
            k: [-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-20,-30,-30,-40,-40,-30,-30,-20,-10,-20,-20,-20,-20,-20,-20,-10, 20, 20,  0,  0,  0,  0, 20, 20, 20, 30, 10,  0,  0, 10, 30, 20]
        };
        const PIECE_VALS = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
        const OPENING_BOOK = {
            "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq": [{r:6,c:4,to:{r:4,c:4}}, {r:6,c:3,to:{r:4,c:3}}],
            "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq": [{r:1,c:2,to:{r:3,c:2}}, {r:1,c:4,to:{r:3,c:4}}],
            "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq": [{r:7,c:6,to:{r:5,c:5}}, {r:7,c:1,to:{r:5,c:2}}],
            "rnbqkbnr/pppp1ppp/8/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq": [{r:0,c:1,to:{r:2,c:2}}],
            "rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq": [{r:7,c:6,to:{r:5,c:5}}],
            "rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR w KQkq": [{r:1,c:3,to:{r:3,c:3}}, {r:0,c:6,to:{r:2,c:5}}],
            "rnbqkbnr/ppp1pppp/8/3p4/3P4/8/PPP1PPPP/RNBQKBNR w KQkq": [{r:6,c:2,to:{r:4,c:2}}],
            "rnbqkb1r/pppppppp/5n2/8/3P4/8/PPP1PPPP/RNBQKBNR w KQkq": [{r:6,c:2,to:{r:4,c:2}}],
        };

        function generateSimpleFEN(board, turn, castling) {
            let fen = "";
            for (let r = 0; r < 8; r++) {
                let empty = 0;
                for (let c = 0; c < 8; c++) {
                    const p = board[r][c];
                    if (!p) { empty++; }
                    else {
                        if (empty > 0) { fen += empty; empty = 0; }
                        const char = p[1] === 'n' ? 'n' : p[1];
                        let pieceChar = p[0] === 'w' ? char.toUpperCase() : char.toLowerCase();
                        fen += pieceChar;
                    }
                }
                if (empty > 0) fen += empty;
                if (r < 7) fen += "/";
            }
            fen += " " + turn;
            let castleStr = "";
            if (castling.w.k) castleStr += "K";
            if (castling.w.q) castleStr += "Q";
            if (castling.b.k) castleStr += "k";
            if (castling.b.q) castleStr += "q";
            if (castleStr === "") castleStr = "-";
            fen += " " + castleStr;
            return fen;
        }

        class ChessEngine {
            constructor(level) { this.level = level; }
            
            getBestMove(game, color) {
                const currentFen = generateSimpleFEN(game.board, game.turn, game.castling);
                if (OPENING_BOOK[currentFen]) {
                    const moves = OPENING_BOOK[currentFen];
                    const randMove = moves[Math.floor(Math.random() * moves.length)];
                    const validMoves = game.getValidMoves(randMove.r, randMove.c);
                    const matched = validMoves.find(m => m.r === randMove.to.r && m.c === randMove.to.c);
                    if (matched) return { score: 0, move: { from: {r: randMove.r, c: randMove.c}, to: matched }, book: true };
                }
                let depth = 1;
                if (this.level >= 3) depth = 2;
                if (this.level >= 5) depth = 3;
                if (this.level >= 8) depth = 4;
                const isMax = (color === 'w');
                return this.minimax(game, depth, -30000, 30000, isMax, color);
            }

            evaluate(game) {
                let score = 0;
                for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                    const p = game.board[r][c];
                    if (!p) continue;
                    const type = p[1];
                    const col = p[0];
                    const isWhite = col === 'w';
                    let val = PIECE_VALS[type];
                    let idx = r * 8 + c;
                    if (!isWhite) idx = (7 - r) * 8 + c; 
                    let pst = MG_PST[type] ? MG_PST[type][idx] : 0;
                    if(isWhite) score += (val + pst);
                    else score -= (val + pst);
                }
                return score;
            }

            orderMoves(game, moves) {
                return moves.sort((a, b) => {
                    let scoreA = 0, scoreB = 0;
                    const pA = game.board[a.to.r][a.to.c];
                    const pB = game.board[b.to.r][b.to.c];
                    if (pA) scoreA = 10 * PIECE_VALS[pA[1]] - PIECE_VALS[game.board[a.from.r][a.from.c][1]];
                    if (pB) scoreB = 10 * PIECE_VALS[pB[1]] - PIECE_VALS[game.board[b.from.r][b.from.c][1]];
                    if (a.to.isPromo) scoreA += 900;
                    if (b.to.isPromo) scoreB += 900;
                    return scoreB - scoreA;
                });
            }

            quiescence(game, alpha, beta, isMax, qDepth = 0) {
                if (qDepth > 4) return this.evaluate(game);
                const standPat = this.evaluate(game);
                if (isMax) {
                    if (standPat >= beta) return standPat;
                    if (standPat > alpha) alpha = standPat;
                } else {
                    if (standPat <= alpha) return standPat;
                    if (standPat < beta) beta = standPat;
                }
                const moves = this.getAllMoves(game, isMax ? 'w' : 'b', true); 
                this.orderMoves(game, moves);
                for (const move of moves) {
                    const savedBoard = game.cloneBoard(game.board);
                    game.executeMoveSilent(move.from, move.to, 'q');
                    const score = this.quiescence(game, alpha, beta, !isMax, qDepth + 1);
                    game.board = savedBoard;
                    if (isMax) {
                        if (score >= beta) return beta;
                        if (score > alpha) alpha = score;
                    } else {
                        if (score <= alpha) return alpha;
                        if (score < beta) beta = score;
                    }
                }
                return isMax ? alpha : beta;
            }

            minimax(game, depth, alpha, beta, isMax, color) {
                if (depth === 0) {
                    if (this.level >= 6) return { score: this.quiescence(game, alpha, beta, isMax) };
                    return { score: this.evaluate(game) }; 
                }
                const turn = isMax ? 'w' : 'b';
                let moves = this.getAllMoves(game, turn);
                if (moves.length === 0) {
                    if (game.isCheck(turn, game.board)) return { score: isMax ? -20000 + (10-depth) : 20000 - (10-depth) }; 
                    return { score: 0 }; 
                }
                moves = this.orderMoves(game, moves);
                let bestMove = null;
                let bestScore = isMax ? -Infinity : Infinity;
                for (const move of moves) {
                    const savedBoard = game.cloneBoard(game.board);
                    const savedRights = JSON.parse(JSON.stringify(game.castling));
                    const savedEp = game.epSquare ? {...game.epSquare} : null;
                    game.executeMoveSilent(move.from, move.to, 'q');
                    const res = this.minimax(game, depth - 1, alpha, beta, !isMax, color);
                    game.board = savedBoard; game.castling = savedRights; game.epSquare = savedEp;
                    if (isMax) {
                        if (res.score > bestScore) { bestScore = res.score; bestMove = move; }
                        alpha = Math.max(alpha, bestScore);
                    } else {
                        if (res.score < bestScore) { bestScore = res.score; bestMove = move; }
                        beta = Math.min(beta, bestScore);
                    }
                    if (beta <= alpha) break;
                }
                return { score: bestScore, move: bestMove };
            }

            getAllMoves(game, color, capturesOnly = false) {
                const moves = [];
                for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                    if (game.board[r][c] && game.board[r][c][0] === color) {
                        let valid = game.getValidMoves(r, c);
                        if (capturesOnly) valid = valid.filter(m => game.board[m.r][m.c] !== null);
                        valid.forEach(to => moves.push({ from: {r,c}, to }));
                    }
                }
                return moves;
            }
        }

        class ChessApp {
            constructor() {
                this.mode = 'pvp'; this.botLevel = 1; this.playerSide = 'w'; this.timeLimit = 10;
                this.flipBlack = false; 
                this.engine = new ChessEngine(2); 
                this.lang = 'en'; 
                this.bindEvents();
                this.updateText();
                this.registerSW();
            }
            
            registerSW() {
                if ('serviceWorker' in navigator) navigator.serviceWorker.register('./service-worker.js').catch(console.log);
            }
            
            toggleLanguage() {
                this.lang = this.lang === 'en' ? 'tr' : 'en';
                const btn = document.getElementById('lang-toggle');
                btn.innerText = this.lang === 'en' ? 'üáπüá∑' : 'üá¨üáß';
                this.updateText();
            }
            
            t(key) { return I18N[this.lang][key] || key; }
            
            updateText() {
                document.querySelectorAll('[data-key]').forEach(el => { el.innerText = this.t(el.dataset.key); });
                this.updateFlipButton();
                this.updateTopLabel();
            }

            bindEvents() {
                const click = (sel, cb) => document.querySelectorAll(sel).forEach(b => b.onclick=()=>{ document.querySelectorAll(sel).forEach(x=>x.classList.remove('selected')); b.classList.add('selected'); cb(b); });
                click('.mode-btn', b => { 
                    this.mode = b.dataset.mode; 
                    if(this.mode === 'pvc') document.getElementById('diff-sec').classList.remove('hidden-opt');
                    else document.getElementById('diff-sec').classList.add('hidden-opt');
                    this.updateTopLabel();
                });
                click('.theme-btn', b => document.body.className = `style-classic ${b.dataset.theme}`);
                click('.time-btn', b => this.timeLimit=parseInt(b.dataset.time));
                
                document.getElementById('bot-level').oninput = (e) => {
                    this.botLevel = parseInt(e.target.value);
                    document.getElementById('lvl-txt').innerText = this.botLevel;
                    this.updateTopLabel();
                };
                document.querySelectorAll('.promo-btn').forEach(b => b.onclick = e => { e.stopPropagation(); this.finalizePromo(b.dataset.role); });
            }
            
            updateTopLabel() {
                if (!document.getElementById('top-label')) return;
                const txt = this.mode === 'pvc' ? `Bot (${this.t('botLevel')} ${this.botLevel})` : this.t('opponent');
                document.getElementById('top-label').innerText = txt;
            }

            toggleFlip() { this.flipBlack = !this.flipBlack; this.updateFlipButton(); }
            updateFlipButton() {
                const btn = document.getElementById('flip-btn');
                btn.innerText = `${this.t('flip')}: ${this.flipBlack ? "ON" : "OFF"}`;
                if(this.flipBlack) btn.classList.add('selected'); else btn.classList.remove('selected');
            }

            startGame() {
                document.getElementById('main-menu').classList.add('hidden');
                document.getElementById('game-over-modal').classList.add('hidden');
                document.getElementById('game-area').classList.add('active');
                document.getElementById('nav-controls').classList.remove('visible');
                document.getElementById('eval-bar').classList.remove('visible'); 
                document.getElementById('suggest-btn').classList.remove('visible'); 
                this.clearArrow();
                if(this.mode==='pvc') this.engine.level = this.botLevel;
                this.updateTopLabel();
                this.initGame();
                this.render();
            }
            showMainMenu() { location.reload(); }
            
            initGame() {
                this.board = Array(8).fill(null).map(()=>Array(8).fill(null));
                const s=['r','n','b','q','k','b','n','r'];
                for(let i=0;i<8;i++){ this.board[0][i]='b'+s[i]; this.board[1][i]='bp'; this.board[6][i]='wp'; this.board[7][i]='w'+s[i]; }
                this.turn='w'; this.castling={w:{k:1,q:1},b:{k:1,q:1}}; this.epSquare=null; 
                this.active=true; 
                this.hist=[]; this.fullHistory=[]; 
                this.times={w:this.timeLimit*60,b:this.timeLimit*60}; if(!this.timeLimit) this.times={w:9e5,b:9e5};
                this.reviewIndex = -1; this.isReviewing = false;
                
                // Track clocks for FEN
                this.halfMove = 0; 
                this.fullMove = 1;

                this.fullHistory.push({
                    board: this.cloneBoard(this.board),
                    castling: JSON.parse(JSON.stringify(this.castling)),
                    epSquare: null, move: null, eval: 0, anno: '',
                    hm: 0, fm: 1
                });
                this.updateEvalBar(0);
                this.startClock();
                if(this.mode==='pvc' && this.playerSide==='b') setTimeout(()=>this.botMove(), 500);
            }
            
            cloneBoard(b) { return b.map(r=>[...r]); }
            onBoard(r,c) { return r>=0 && r<8 && c>=0 && c<8; }
            getValidMoves(r, c) {
                const p=this.board[r][c]; if(!p)return[];
                const col=p[0], type=p[1], moves=[];
                if(type==='p'){
                    const d=col==='w'?-1:1;
                    if(!this.board[r+d]?.[c]){
                        moves.push({r:r+d, c, isPromo:r+d===(col==='w'?0:7)});
                        if(r===(col==='w'?6:1) && !this.board[r+d*2]?.[c]) moves.push({r:r+d*2, c});
                    }
                    [[d,-1],[d,1]].forEach(([dr,dc])=>{
                        if(this.onBoard(r+dr,c+dc)) {
                            if (this.board[r+dr][c+dc] && this.board[r+dr][c+dc][0]!==col) moves.push({r:r+dr, c:c+dc, isPromo:r+dr===(col==='w'?0:7)});
                            else if (this.epSquare && this.epSquare.r === r+dr && this.epSquare.c === c+dc) moves.push({r:r+dr, c:c+dc, isEp: true});
                        }
                    });
                } else if(type==='n' || type==='k'){
                    const steps = type==='n' ? [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]] : [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                    steps.forEach(([dr,dc])=>{ if(this.onBoard(r+dr,c+dc) && (!this.board[r+dr][c+dc] || this.board[r+dr][c+dc][0]!==col)) moves.push({r:r+dr, c:c+dc}); });
                    if(type==='k' && !this.isCheck(col,this.board)) {
                        if(this.castling[col].k && !this.board[r][5] && !this.board[r][6] && !this.isAttacked({r,c:5},col,this.board) && !this.isAttacked({r,c:6},col,this.board)) moves.push({r,c:6,castle:'k'});
                        if(this.castling[col].q && !this.board[r][1] && !this.board[r][2] && !this.board[r][3] && !this.isAttacked({r,c:3},col,this.board) && !this.isAttacked({r,c:2},col,this.board)) moves.push({r,c:2,castle:'q'});
                    }
                } else {
                    const dirs = type==='b'?[[1,1],[1,-1],[-1,1],[-1,-1]] : type==='r'?[[0,1],[0,-1],[1,0],[-1,0]] : [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
                    dirs.forEach(([dr,dc])=>{
                        let tr=r+dr, tc=c+dc;
                        while(this.onBoard(tr,tc)){
                            const t=this.board[tr][tc]; if(!t) moves.push({r:tr, c:tc}); else { if(t[0]!==col) moves.push({r:tr, c:tc}); break; }
                            tr+=dr; tc+=dc;
                        }
                    });
                }
                return moves.filter(m=>{ 
                    const nb=this.cloneBoard(this.board); 
                    if (m.isEp) nb[r][m.c] = null; nb[m.r][m.c]=nb[r][c]; nb[r][c]=null; 
                    return !this.isCheck(col, nb); 
                });
            }
            isCheck(col, b) { let kp; for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(b[r][c]===col+'k') kp={r,c}; return kp ? this.isAttacked(kp, col, b) : true; }
            isAttacked(sq, col, b) {
                const en=col==='w'?'b':'w', pd=col==='w'?-1:1;
                if(this.onBoard(sq.r+pd,sq.c-1) && b[sq.r+pd][sq.c-1]===en+'p') return true;
                if(this.onBoard(sq.r+pd,sq.c+1) && b[sq.r+pd][sq.c+1]===en+'p') return true;
                if([[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].some(([dr,dc])=>this.onBoard(sq.r+dr,sq.c+dc) && b[sq.r+dr][sq.c+dc]===en+'n')) return true;
                const dirs=[[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
                for(let [dr,dc] of dirs){
                    let r=sq.r+dr, c=sq.c+dc, diag=Math.abs(dr)===Math.abs(dc);
                    while(this.onBoard(r,c)){ const t=b[r][c]; if(t){ if((diag&&(t===en+'b'||t===en+'q')) || (!diag&&(t===en+'r'||t===en+'q')) || (t===en+'k'&&Math.abs(sq.r-r)<2)) return true; break; } r+=dr; c+=dc; }
                }
                return false;
            }
            handleSquare(r, c) {
                if(this.isReviewing) return; 
                if(!this.active || (this.mode==='pvc' && this.turn!==this.playerSide)) return;
                if(this.promo) return;
                const p=this.board[r][c], m=this.moves?.find(x=>x.r===r && x.c===c);
                if(this.sel && m) this.move(this.sel, m);
                else if(p && p[0]===this.turn) { this.sel={r,c}; this.moves=this.getValidMoves(r,c); this.render(); }
                else { this.sel=null; this.moves=[]; this.render(); }
            }
            move(from, to, promoType=null) {
                if(to.isPromo && !promoType) { this.promo={from, to}; document.getElementById('promotion-modal').classList.add('active'); return; }
                
                // 1. Generate Basic Notation (before move)
                const p = this.board[from.r][from.c];
                const cap = this.board[to.r][to.c];
                let note = this.genNote(from, to, p, cap, to.castle, to.isPromo, promoType);
                
                // Update FEN clocks
                if (p[1] === 'p' || cap) this.halfMove = 0; else this.halfMove++;
                if (this.turn === 'b') this.fullMove++;

                // 2. Execute Move
                this.executeMoveSilent(from, to, promoType||'q');
                
                // 3. Check for Check/Mate (after move)
                const opp = this.turn==='w'?'b':'w';
                const inCheck = this.isCheck(opp, this.board);
                
                // Check if opponent has no moves
                let canMove = false;
                for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
                    if(this.board[r][c] && this.board[r][c][0]===opp && this.getValidMoves(r,c).length) canMove = true;
                }
                
                if (inCheck) {
                    note += canMove ? "+" : "#";
                }

                // 4. Store History
                this.hist.push(note);
                this.fullHistory.push({
                    board: this.cloneBoard(this.board),
                    castling: JSON.parse(JSON.stringify(this.castling)),
                    epSquare: this.epSquare ? {...this.epSquare} : null,
                    move: {from, to, note}, eval: 0, anno: '',
                    hm: this.halfMove, fm: this.fullMove
                });

                // 5. Switch Turn
                this.turn = opp;
                this.lastMove = {from, to};
                this.sel = null; this.moves = [];
                this.render();

                // 6. End Game or Bot Move
                if (!canMove) {
                    this.end(inCheck ? (this.turn==='w'?'b':'w') : null, inCheck?"Checkmate":"Stalemate");
                } else if (this.mode === 'pvc' && this.turn !== this.playerSide) {
                    setTimeout(() => this.botMove(), 100);
                }
            }
            executeMoveSilent(from, to, pt='q') {
                const p=this.board[from.r][from.c]; 
                if (p[1] === 'p' && from.c !== to.c && !this.board[to.r][to.c]) this.board[from.r][to.c] = null;
                this.board[to.r][to.c]=to.isPromo?p[0]+pt:p; this.board[from.r][from.c]=null;
                if(to.castle){ if(to.castle==='k'){this.board[from.r][5]=this.board[from.r][7];this.board[from.r][7]=null;} else{this.board[from.r][3]=this.board[from.r][0];this.board[from.r][0]=null;} }
                if(p[1]==='k') this.castling[p[0]].k=this.castling[p[0]].q=0;
                if(p[1]==='r') { if(from.c===0) this.castling[p[0]].q=0; if(from.c===7) this.castling[p[0]].k=0; }
                if (p[1] === 'p' && Math.abs(from.r - to.r) === 2) this.epSquare = { r: (from.r + to.r) / 2, c: from.c }; else this.epSquare = null;
            }
            async botMove() {
                const res = await new Promise(r=>setTimeout(()=>r(this.engine.getBestMove(this, this.turn)), 50));
                if(res.move) this.move(res.move.from, res.move.to, res.move.to.isPromo?'q':null);
            }
            finalizePromo(t) { const {from, to}=this.promo; document.getElementById('promotion-modal').classList.remove('active'); this.promo=null; this.move(from, to, t); }
            
            genNote(from, to, p, capture, castle, promo, pt) {
                // Castling
                if (castle) return castle === 'k' ? "O-O" : "O-O-O";

                const type = p[1];
                const color = p[0];
                const destCoords = COLS[to.c] + (8 - to.r);
                const isCapture = capture || (type === 'p' && from.c !== to.c); // EP is a capture
                
                // Pawn moves
                if (type === 'p') {
                    if (isCapture) {
                        return COLS[from.c] + "x" + destCoords + (promo ? "=" + pt.toUpperCase() : "");
                    } else {
                        return destCoords + (promo ? "=" + pt.toUpperCase() : "");
                    }
                }

                // Piece moves with Disambiguation
                const pieceChar = SAN_PIECES[type]; // K, Q, R, B, N
                
                let disambig = "";
                const candidates = [];
                
                // Find all same pieces of same color
                for(let r=0; r<8; r++) {
                    for(let c=0; c<8; c++) {
                        const sq = this.board[r][c];
                        if (sq && sq[0] === color && sq[1] === type) {
                            if (r === from.r && c === from.c) continue; // Skip self
                            // Check if this candidate can move to 'to'
                            const moves = this.getValidMoves(r, c);
                            if (moves.some(m => m.r === to.r && m.c === to.c)) {
                                candidates.push({r, c});
                            }
                        }
                    }
                }

                if (candidates.length > 0) {
                    let fileMatch = false;
                    let rankMatch = false;
                    
                    for (const cand of candidates) {
                        if (cand.c === from.c) fileMatch = true;
                        if (cand.r === from.r) rankMatch = true;
                    }

                    if (!fileMatch) {
                        disambig = COLS[from.c];
                    } else if (!rankMatch) {
                        disambig = (8 - from.r);
                    } else {
                        disambig = COLS[from.c] + (8 - from.r);
                    }
                }

                return pieceChar + disambig + (isCapture ? "x" : "") + destCoords;
            }

            updateEvalBar(score) {
                const s = (typeof score === 'number') ? score : 0;
                let pct = 50 + (s / 1500) * 50; pct = Math.max(5, Math.min(95, pct)); 
                document.getElementById('eval-fill').style.height = `${pct}%`;
                const displayScore = (Math.abs(s) / 100).toFixed(1);
                document.getElementById('eval-text').innerText = (s >= 0 ? "+" : "-") + displayScore;
            }
            render() {
                const b=document.getElementById('board'); b.innerHTML='';
                const isW=this.playerSide==='w', rows=isW?[0,1,2,3,4,5,6,7]:[7,6,5,4,3,2,1,0], cols=isW?[0,1,2,3,4,5,6,7]:[7,6,5,4,3,2,1,0];
                const check=this.isCheck(this.turn, this.board);
                rows.forEach(r=>{
                    cols.forEach(c=>{
                        const d=document.createElement('div'); d.className=`square ${(r+c)%2?'dark':'light'}`;
                        if(this.sel?.r===r && this.sel?.c===c) d.classList.add('selected');
                        let lm = this.lastMove;
                        if (this.isReviewing && this.reviewIndex > 0) lm = this.fullHistory[this.reviewIndex].move;
                        if(lm && (lm.from.r===r && lm.from.c===c || lm.to.r===r && lm.to.c===c)) d.classList.add('last-move');
                        const p=this.board[r][c];
                        if(check && p===this.turn+'k') d.classList.add('in-check');
                        if(this.moves?.some(m=>m.r===r && m.c===c)) p?d.classList.add('valid-capture'):d.classList.add('valid-move');
                        if (this.moves?.some(m=>m.r===r && m.c===c && m.isEp)) { d.classList.remove('valid-move'); d.classList.add('valid-capture'); }
                        if(p) {
                            let pieceClass = `piece ${p[0]==='w'?'white':'black'}`;
                            if (p[0] === 'b' && this.flipBlack) pieceClass += ' flipped';
                            d.innerHTML=`<div class="${pieceClass}">${PIECES[p[0]][p[1]]}</div>`;
                        }
                        if (this.isReviewing && this.reviewIndex > 0) {
                            const step = this.fullHistory[this.reviewIndex];
                            if (step.anno && step.move.to.r === r && step.move.to.c === c) {
                                let cls = '';
                                let content = step.anno;
                                if (step.anno === '!!') cls = 'anno-brilliant';
                                else if (step.anno === '!') cls = 'anno-good';
                                else if (step.anno === '?') cls = 'anno-mistake';
                                else if (step.anno === 'X') cls = 'anno-blunder';
                                else if (step.anno === 'book') { cls = 'anno-book'; content = 'üìñ'; }
                                if (cls) d.innerHTML += `<div class="annotation ${cls}">${content}</div>`;
                            }
                        }
                        d.onclick=e=>{e.stopPropagation();this.handleSquare(r,c)};
                        b.appendChild(d);
                    });
                });
                const h=document.getElementById('history-panel'); h.innerHTML='';
                for(let i=0;i<this.hist.length;i+=2) {
                    const idx = i/2;
                    const isActive = this.isReviewing && (Math.floor((this.reviewIndex-1)/2) === idx);
                    let wAnno = '', bAnno = '';
                    const getAnnoHtml = (step) => {
                         if (!step?.anno) return '';
                         if (step.anno === 'book') return `<span class="hist-anno book">üìñ</span>`;
                         return `<span class="hist-anno ${step.anno === '!' ? 'good' : step.anno === '?' ? 'bad' : 'blunder'}">${step.anno}</span>`;
                    };
                    wAnno = getAnnoHtml(this.fullHistory[i+1]);
                    bAnno = getAnnoHtml(this.fullHistory[i+2]);
                    h.innerHTML+=`<div class="history-row ${isActive?'active-row':''}" onclick="app.navJump(${i+1})">
                        <div class="history-num">${idx+1}.</div>
                        <div class="history-move">${this.hist[i]}${wAnno}</div>
                        <div class="history-move">${this.hist[i+1]||''}${bAnno}</div>
                    </div>`;
                }
                if (!this.isReviewing) h.scrollTop=h.scrollHeight;
            }
            startClock() { if(this.int) clearInterval(this.int); if(!this.timeLimit) return; this.int=setInterval(()=>{ if(!this.active)return; this.times[this.turn]--; this.updClock(); if(this.times[this.turn]<=0)this.end(this.turn==='w'?'b':'w',"time"); },1000); }
            updClock() { 
                const fmt=s=>`${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
                document.getElementById('clock-bottom').innerText=fmt(this.times[this.playerSide]);
                document.getElementById('clock-top').innerText=fmt(this.times[this.playerSide==='w'?'b':'w']);
            }
            end(w,r) { 
                this.active=false; this.isReviewing=false; 
                let title = "";
                if (!w) title = this.t('draw');
                else if (w === 'w') title = this.t('whiteWon');
                else title = this.t('blackWon');
                let reason = r;
                if (r === "Resigned") reason = this.t('resigned');
                if (r === "Checkmate") reason = this.t('checkmate');
                if (r === "Stalemate") reason = this.t('stalemate');
                if (r === "time") reason = this.t('time');
                document.getElementById('end-title').innerText = title; 
                document.getElementById('end-reason').innerText = reason; 
                document.getElementById('game-over-modal').classList.remove('hidden'); 
            }
            promptResign() { document.getElementById('resign-modal').classList.remove('hidden'); }
            doResign() { document.getElementById('resign-modal').classList.add('hidden'); this.end(this.turn==='w'?'b':'w', "Resigned"); }

            undoMove() {
                if (!this.active || this.isReviewing) return;
                let steps = 1;
                if (this.mode === 'pvc') {
                    if (this.turn === this.playerSide && this.fullHistory.length > 2) steps = 2;
                    else if (this.turn !== this.playerSide) steps = 1;
                    else return; 
                }
                if (this.fullHistory.length <= steps) return; 
                for(let i=0; i<steps; i++) { this.fullHistory.pop(); this.hist.pop(); this.turn = this.turn==='w'?'b':'w'; }
                const prev = this.fullHistory[this.fullHistory.length - 1];
                this.board = this.cloneBoard(prev.board);
                this.castling = JSON.parse(JSON.stringify(prev.castling));
                this.epSquare = prev.epSquare ? {...prev.epSquare} : null;
                this.lastMove = prev.move ? {from: prev.move.from, to: prev.move.to} : null;
                this.sel = null; this.moves = [];
                // Restore counters if stored
                this.halfMove = prev.hm || 0;
                this.fullMove = prev.fm || 1;
                this.render();
            }

            async startAnalysis() {
                document.getElementById('game-over-modal').classList.add('hidden');
                document.getElementById('loading-overlay').classList.remove('hidden');
                const anaEngine = new ChessEngine(8);
                const tempGame = new ChessApp();
                tempGame.engine = anaEngine;

                try {
                    for (let i = 1; i < this.fullHistory.length; i++) {
                        // Pause briefly each step to allow UI to update
                        await new Promise(r => setTimeout(r, 10));

                        const prevStep = this.fullHistory[i-1];
                        const currStep = this.fullHistory[i];
                        tempGame.board = this.cloneBoard(prevStep.board);
                        tempGame.castling = JSON.parse(JSON.stringify(prevStep.castling));
                        tempGame.epSquare = prevStep.epSquare ? {...prevStep.epSquare} : null;
                        
                        // If i=1 (first move), it was White's turn to move.
                        const turn = (i % 2 !== 0) ? 'w' : 'b';
                        
                        const fen = generateSimpleFEN(tempGame.board, turn, tempGame.castling);
                        let isBook = false;
                        if (OPENING_BOOK[fen]) {
                            const bookMoves = OPENING_BOOK[fen];
                            const played = currStep.move;
                            if (bookMoves.some(bm => bm.r === played.from.r && bm.c === played.from.c && bm.to.r === played.to.r && bm.to.c === played.to.c)) isBook = true;
                        }

                        if (isBook) { currStep.anno = 'book'; currStep.eval = 0; } 
                        else {
                            const bestObj = anaEngine.getBestMove(tempGame, turn);
                            const movePlayed = currStep.move;
                            
                            // Prevent crash if game ended in mate (bestObj might have no move)
                            if (bestObj && bestObj.move) {
                                tempGame.executeMoveSilent(movePlayed.from, movePlayed.to, 'q');
                                const afterObj = anaEngine.minimax(tempGame, 2, -Infinity, Infinity, turn==='b', turn==='w'?'b':'w');
                                currStep.eval = afterObj.score;
                                
                                let diff = 0;
                                // If turn was White, Positive Diff means White lost advantage (Bad).
                                // If turn was Black, Positive Diff means Black lost advantage (Bad).
                                // score is always White-relative.
                                if (turn === 'w') diff = bestObj.score - afterObj.score; 
                                else diff = afterObj.score - bestObj.score;

                                if (diff < 20 && movePlayed.from.r === bestObj.move.from.r && movePlayed.to.r === bestObj.move.to.r) currStep.anno = '!!';
                                else if (diff < 50) currStep.anno = '';
                                else if (diff < 150) currStep.anno = '!';
                                else if (diff < 300) currStep.anno = '?';
                                else currStep.anno = 'X';
                            }
                        }
                    }
                } catch (e) {
                    console.error("Analysis interrupted", e);
                }
                
                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('nav-controls').classList.add('visible');
                document.getElementById('suggest-btn').classList.add('visible'); 
                document.getElementById('eval-bar').classList.add('visible'); 
                
                this.isReviewing = true;
                this.navStart();
            }
            setReviewState(idx) {
                if (idx < 0) idx = 0;
                if (idx >= this.fullHistory.length) idx = this.fullHistory.length - 1;
                this.reviewIndex = idx;
                const step = this.fullHistory[idx];
                this.board = this.cloneBoard(step.board);
                this.castling = JSON.parse(JSON.stringify(step.castling));
                this.epSquare = step.epSquare ? {...step.epSquare} : null;
                this.lastMove = step.move ? {from: step.move.from, to: step.move.to} : null;
                this.updateEvalBar(step.eval);
                this.clearArrow();
                this.render();
            }

            suggestMove() {
                if (!this.isReviewing) return;
                const toMove = (this.reviewIndex % 2 === 0) ? 'w' : 'b';
                const tempGame = new ChessApp();
                tempGame.board = this.cloneBoard(this.board);
                tempGame.castling = JSON.parse(JSON.stringify(this.castling));
                tempGame.epSquare = this.epSquare;
                
                const suggestion = new ChessEngine(8).getBestMove(tempGame, toMove);
                if (suggestion && suggestion.move) {
                    this.drawArrow(suggestion.move.from, suggestion.move.to);
                }
            }

            drawArrow(from, to) {
                this.clearArrow();
                const layer = document.getElementById('arrow-layer');
                const isWhite = this.playerSide === 'w';
                
                const getCoord = (r, c) => {
                    const y = isWhite ? r : 7-r;
                    const x = isWhite ? c : 7-c;
                    return { x: x * 12.5 + 6.25, y: y * 12.5 + 6.25 };
                };
                const start = getCoord(from.r, from.c);
                const end = getCoord(to.r, to.c);

                const arrow = document.createElementNS("http://www.w3.org/2000/svg", "line");
                arrow.setAttribute("x1", start.x);
                arrow.setAttribute("y1", start.y);
                arrow.setAttribute("x2", end.x);
                arrow.setAttribute("y2", end.y);
                arrow.setAttribute("stroke", "#26c281");
                arrow.setAttribute("stroke-width", "2");
                arrow.setAttribute("marker-end", "url(#arrowhead)");
                arrow.setAttribute("opacity", "0.8");
                layer.appendChild(arrow);
            }

            clearArrow() { document.getElementById('arrow-layer').innerHTML = ''; }
            navStart() { this.setReviewState(0); }
            navEnd() { this.setReviewState(this.fullHistory.length - 1); }
            navPrev() { this.setReviewState(this.reviewIndex - 1); }
            navNext() { this.setReviewState(this.reviewIndex + 1); }
            navJump(idx) { if (this.isReviewing) this.setReviewState(idx); }

            // --- EXPORT FEATURES ---
            showExportMenu() {
                const pgn = this.generatePGN();
                document.getElementById('pgn-area').value = pgn;
                
                const fen = this.generateCurrentFEN();
                document.getElementById('fen-area').value = fen;
                
                document.getElementById('export-modal').classList.remove('hidden');
            }
            
            generatePGN() {
                let pgn = `[Event "Chessy Game"]\n[Site "Chessy Web App"]\n[Date "${new Date().toISOString().split('T')[0]}"]\n`;
                pgn += `[White "${this.playerSide==='w'?'Human':'Bot'}"]\n[Black "${this.playerSide==='b'?'Human':'Bot'}"]\n[Result "*"]\n\n`;
                for(let i=0; i<this.hist.length; i+=2) {
                    pgn += `${Math.floor(i/2)+1}. ${this.hist[i]} `;
                    if(this.hist[i+1]) pgn += `${this.hist[i+1]} `;
                }
                return pgn.trim();
            }

            generateCurrentFEN() {
                // Reuse logic from generateSimpleFEN but add clocks
                const board = this.board;
                const turn = this.isReviewing ? ((this.reviewIndex % 2 === 0) ? 'w' : 'b') : this.turn;
                // Note: reviewing FENs uses stored board, so this works if we use this.board
                // But we need to be careful about state if reviewing
                
                let fen = generateSimpleFEN(this.board, turn, this.castling);
                
                // Add En Passant
                if (this.epSquare) {
                    fen += " " + COLS[this.epSquare.c] + (8 - this.epSquare.r);
                } else {
                    fen += " -";
                }

                // Add Clocks (Approximated for review, exact for current)
                // If reviewing, we use stored history step if available
                let hm = this.halfMove;
                let fm = this.fullMove;
                if (this.isReviewing && this.fullHistory[this.reviewIndex]) {
                    hm = this.fullHistory[this.reviewIndex].hm || 0;
                    fm = this.fullHistory[this.reviewIndex].fm || 1;
                }
                fen += ` ${hm} ${fm}`;
                return fen;
            }

            copyPGN() {
                const txt = document.getElementById('pgn-area');
                txt.select();
                document.execCommand('copy');
                alert("PGN Copied to clipboard!");
            }

            copyFEN() {
                const txt = document.getElementById('fen-area');
                txt.select();
                document.execCommand('copy');
                alert("FEN Copied to clipboard!");
            }
        }
        const app = new ChessApp();
    </script>
</body>
</html>

